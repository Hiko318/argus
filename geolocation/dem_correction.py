"""\nDigital Elevation Model (DEM) Correction Module for Foresight SAR System\n\nThis module provides terrain-aware geolocation by incorporating digital\nelevation models to correct for ground height variations. Supports various\nDEM formats and interpolation methods for accurate ground intersection\ncalculations.\n"""\n\nimport numpy as np\nfrom typing import Optional, Tuple, Union, List, Dict, Any\nfrom dataclasses import dataclass\nfrom pathlib import Path\nimport logging\nfrom enum import Enum\nimport json\n\ntry:\n    import rasterio\n    from rasterio.transform import from_bounds\n    from rasterio.warp import transform_bounds, reproject\n    from rasterio.crs import CRS\n    RASTERIO_AVAILABLE = True\nexcept ImportError:\n    RASTERIO_AVAILABLE = False\n    logging.warning(\"Rasterio not available, DEM functionality will be limited\")\n\nfrom .coordinate_transform import CoordinateTransformer, GeodeticCoordinate\nfrom .projection import Ray3D\n\n\nclass InterpolationMethod(Enum):\n    \"\"\"DEM interpolation methods\"\"\"\n    NEAREST = \"nearest\"\n    BILINEAR = \"bilinear\"\n    BICUBIC = \"bicubic\"\n    LANCZOS = \"lanczos\"\n\n\nclass DEMFormat(Enum):\n    \"\"\"Supported DEM formats\"\"\"\n    GEOTIFF = \"geotiff\"\n    SRTM = \"srtm\"\n    ASTER = \"aster\"\n    ALOS = \"alos\"\n    CUSTOM = \"custom\"\n\n\n@dataclass\nclass DEMMetadata:\n    \"\"\"DEM metadata information\"\"\"\n    format: DEMFormat\n    resolution: float  # meters per pixel\n    bounds: Tuple[float, float, float, float]  # (min_lon, min_lat, max_lon, max_lat)\n    crs: str  # Coordinate reference system\n    nodata_value: Optional[float] = None\n    vertical_datum: str = \"EGM96\"\n    horizontal_accuracy: Optional[float] = None\n    vertical_accuracy: Optional[float] = None\n    source: Optional[str] = None\n    date_acquired: Optional[str] = None\n\n\nclass DEMTile:\n    \"\"\"Single DEM tile\"\"\"\n    \n    def __init__(self, data: np.ndarray, metadata: DEMMetadata, \n                 transform: Optional[Any] = None):\n        \"\"\"\n        Initialize DEM tile\n        \n        Args:\n            data: Elevation data array\n            metadata: DEM metadata\n            transform: Rasterio transform object\n        \"\"\"\n        self.data = data\n        self.metadata = metadata\n        self.transform = transform\n        \n        # Calculate pixel size if not provided\n        if transform and hasattr(transform, 'a'):\n            self.pixel_size_x = abs(transform.a)\n            self.pixel_size_y = abs(transform.e)\n        else:\n            self.pixel_size_x = self.metadata.resolution\n            self.pixel_size_y = self.metadata.resolution\n    \n    def get_elevation_at_pixel(self, row: int, col: int) -> Optional[float]:\n        \"\"\"Get elevation at specific pixel coordinates\"\"\"\n        if (0 <= row < self.data.shape[0] and \n            0 <= col < self.data.shape[1]):\n            value = self.data[row, col]\n            if (self.metadata.nodata_value is None or \n                value != self.metadata.nodata_value):\n                return float(value)\n        return None\n    \n    def get_elevation_at_coord(self, lon: float, lat: float, \n                              method: InterpolationMethod = InterpolationMethod.BILINEAR) -> Optional[float]:\n        \"\"\"\n        Get elevation at geographic coordinates\n        \n        Args:\n            lon: Longitude in degrees\n            lat: Latitude in degrees\n            method: Interpolation method\n            \n        Returns:\n            Elevation in meters or None if outside bounds\n        \"\"\"\n        # Convert geographic coordinates to pixel coordinates\n        if self.transform:\n            try:\n                import rasterio\n                col, row = ~self.transform * (lon, lat)\n            except:\n                # Fallback calculation\n                min_lon, min_lat, max_lon, max_lat = self.metadata.bounds\n                col = (lon - min_lon) / self.pixel_size_x\n                row = (max_lat - lat) / self.pixel_size_y\n        else:\n            # Simple calculation based on bounds\n            min_lon, min_lat, max_lon, max_lat = self.metadata.bounds\n            col = (lon - min_lon) / self.pixel_size_x\n            row = (max_lat - lat) / self.pixel_size_y\n        \n        return self._interpolate_elevation(row, col, method)\n    \n    def _interpolate_elevation(self, row: float, col: float, \n                              method: InterpolationMethod) -> Optional[float]:\n        \"\"\"Interpolate elevation at fractional pixel coordinates\"\"\"\n        if method == InterpolationMethod.NEAREST:\n            return self.get_elevation_at_pixel(int(round(row)), int(round(col)))\n        \n        elif method == InterpolationMethod.BILINEAR:\n            return self._bilinear_interpolation(row, col)\n        \n        elif method == InterpolationMethod.BICUBIC:\n            return self._bicubic_interpolation(row, col)\n        \n        else:\n            # Fallback to bilinear\n            return self._bilinear_interpolation(row, col)\n    \n    def _bilinear_interpolation(self, row: float, col: float) -> Optional[float]:\n        \"\"\"Bilinear interpolation\"\"\"\n        # Get integer and fractional parts\n        row_int, col_int = int(row), int(col)\n        row_frac, col_frac = row - row_int, col - col_int\n        \n        # Get four corner elevations\n        elevations = []\n        for dr, dc in [(0, 0), (0, 1), (1, 0), (1, 1)]:\n            elev = self.get_elevation_at_pixel(row_int + dr, col_int + dc)\n            if elev is None:\n                return None\n            elevations.append(elev)\n        \n        e00, e01, e10, e11 = elevations\n        \n        # Bilinear interpolation\n        e0 = e00 * (1 - col_frac) + e01 * col_frac\n        e1 = e10 * (1 - col_frac) + e11 * col_frac\n        elevation = e0 * (1 - row_frac) + e1 * row_frac\n        \n        return elevation\n    \n    def _bicubic_interpolation(self, row: float, col: float) -> Optional[float]:\n        \"\"\"Bicubic interpolation (simplified)\"\"\"\n        # For now, fallback to bilinear\n        # Full bicubic would require 4x4 neighborhood\n        return self._bilinear_interpolation(row, col)\n    \n    def is_point_in_bounds(self, lon: float, lat: float) -> bool:\n        \"\"\"Check if point is within DEM bounds\"\"\"\n        min_lon, min_lat, max_lon, max_lat = self.metadata.bounds\n        return (min_lon <= lon <= max_lon and \n                min_lat <= lat <= max_lat)\n\n\nclass DEMCorrector:\n    \"\"\"DEM-based terrain correction\"\"\"\n    \n    def __init__(self, coordinate_transformer: Optional[CoordinateTransformer] = None):\n        \"\"\"\n        Initialize DEM corrector\n        \n        Args:\n            coordinate_transformer: Coordinate transformer instance\n        \"\"\"\n        self.coordinate_transformer = coordinate_transformer or CoordinateTransformer()\n        self.dem_tiles: List[DEMTile] = []\n        self.default_elevation = 0.0\n        self.cache = {}  # Simple elevation cache\n        self.cache_size_limit = 10000\n    \n    def load_dem_file(self, file_path: str, dem_format: DEMFormat = DEMFormat.GEOTIFF) -> DEMTile:\n        \"\"\"\n        Load DEM from file\n        \n        Args:\n            file_path: Path to DEM file\n            dem_format: DEM format\n            \n        Returns:\n            Loaded DEM tile\n        \"\"\"\n        if not RASTERIO_AVAILABLE:\n            raise ImportError(\"Rasterio is required for DEM file loading\")\n        \n        try:\n            with rasterio.open(file_path) as dataset:\n                # Read elevation data\n                data = dataset.read(1)\n                \n                # Get metadata\n                bounds = dataset.bounds\n                metadata = DEMMetadata(\n                    format=dem_format,\n                    resolution=min(abs(dataset.transform.a), abs(dataset.transform.e)),\n                    bounds=(bounds.left, bounds.bottom, bounds.right, bounds.top),\n                    crs=str(dataset.crs),\n                    nodata_value=dataset.nodata\n                )\n                \n                # Create DEM tile\n                dem_tile = DEMTile(data, metadata, dataset.transform)\n                self.dem_tiles.append(dem_tile)\n                \n                logging.info(f\"Loaded DEM from {file_path}: {data.shape} pixels, resolution={metadata.resolution}m\")\n                return dem_tile\n                \n        except Exception as e:\n            logging.error(f\"Failed to load DEM from {file_path}: {e}\")\n            raise\n    \n    def create_synthetic_dem(self, bounds: Tuple[float, float, float, float],\n                           resolution: float = 30.0,\n                           base_elevation: float = 0.0,\n                           terrain_variation: float = 100.0) -> DEMTile:\n        \"\"\"\n        Create synthetic DEM for testing\n        \n        Args:\n            bounds: Geographic bounds (min_lon, min_lat, max_lon, max_lat)\n            resolution: Resolution in meters\n            base_elevation: Base elevation in meters\n            terrain_variation: Maximum terrain variation in meters\n            \n        Returns:\n            Synthetic DEM tile\n        \"\"\"\n        min_lon, min_lat, max_lon, max_lat = bounds\n        \n        # Calculate grid size\n        width_deg = max_lon - min_lon\n        height_deg = max_lat - min_lat\n        \n        # Approximate degrees per meter (rough estimate)\n        deg_per_meter_lat = 1.0 / 111320.0\n        deg_per_meter_lon = 1.0 / (111320.0 * np.cos(np.radians((min_lat + max_lat) / 2)))\n        \n        cols = int(width_deg / (resolution * deg_per_meter_lon))\n        rows = int(height_deg / (resolution * deg_per_meter_lat))\n        \n        # Generate synthetic terrain\n        x = np.linspace(0, 1, cols)\n        y = np.linspace(0, 1, rows)\n        X, Y = np.meshgrid(x, y)\n        \n        # Simple terrain model with some hills and valleys\n        terrain = (base_elevation + \n                  terrain_variation * 0.3 * np.sin(4 * np.pi * X) * np.cos(3 * np.pi * Y) +\n                  terrain_variation * 0.2 * np.sin(8 * np.pi * X) +\n                  terrain_variation * 0.1 * np.cos(6 * np.pi * Y) +\n                  terrain_variation * 0.05 * np.random.normal(0, 1, (rows, cols)))\n        \n        # Create metadata\n        metadata = DEMMetadata(\n            format=DEMFormat.CUSTOM,\n            resolution=resolution,\n            bounds=bounds,\n            crs=\"EPSG:4326\",\n            vertical_datum=\"WGS84\"\n        )\n        \n        dem_tile = DEMTile(terrain.astype(np.float32), metadata)\n        self.dem_tiles.append(dem_tile)\n        \n        logging.info(f\"Created synthetic DEM: {rows}x{cols} pixels, resolution={resolution}m\")\n        return dem_tile\n    \n    def get_elevation(self, lon: float, lat: float, \n                     method: InterpolationMethod = InterpolationMethod.BILINEAR) -> float:\n        \"\"\"\n        Get elevation at geographic coordinates\n        \n        Args:\n            lon: Longitude in degrees\n            lat: Latitude in degrees\n            method: Interpolation method\n            \n        Returns:\n            Elevation in meters\n        \"\"\"\n        # Check cache first\n        cache_key = (round(lon, 6), round(lat, 6), method.value)\n        if cache_key in self.cache:\n            return self.cache[cache_key]\n        \n        # Find appropriate DEM tile\n        for dem_tile in self.dem_tiles:\n            if dem_tile.is_point_in_bounds(lon, lat):\n                elevation = dem_tile.get_elevation_at_coord(lon, lat, method)\n                if elevation is not None:\n                    # Cache result\n                    if len(self.cache) < self.cache_size_limit:\n                        self.cache[cache_key] = elevation\n                    return elevation\n        \n        # Return default elevation if no DEM available\n        return self.default_elevation\n    \n    def correct_ray_ground_intersection(self, ray: Ray3D, \n                                      initial_intersection: np.ndarray,\n                                      max_iterations: int = 10,\n                                      tolerance: float = 1.0) -> Optional[np.ndarray]:\n        \"\"\"\n        Correct ray-ground intersection using DEM\n        \n        Args:\n            ray: 3D ray\n            initial_intersection: Initial ground intersection point\n            max_iterations: Maximum iterations for convergence\n            tolerance: Convergence tolerance in meters\n            \n        Returns:\n            Corrected intersection point or None if no convergence\n        \"\"\"\n        if not self.dem_tiles:\n            return initial_intersection\n        \n        current_point = initial_intersection.copy()\n        \n        for iteration in range(max_iterations):\n            # Convert to geodetic coordinates\n            if self.coordinate_transformer.reference_point:\n                # Assume current_point is in ENU coordinates\n                geodetic = self.coordinate_transformer.enu_to_geodetic(current_point)\n            else:\n                # Assume current_point is already in geodetic format [lon, lat, alt]\n                geodetic = GeodeticCoordinate(\n                    latitude=current_point[1],\n                    longitude=current_point[0],\n                    altitude=current_point[2]\n                )\n            \n            # Get DEM elevation at this location\n            dem_elevation = self.get_elevation(geodetic.longitude, geodetic.latitude)\n            \n            # Calculate height difference\n            height_diff = abs(geodetic.altitude - dem_elevation)\n            \n            if height_diff < tolerance:\n                # Converged\n                break\n            \n            # Find intersection with DEM elevation plane\n            corrected_intersection = ray.intersect_plane(\n                plane_point=np.array([0, 0, dem_elevation]),\n                plane_normal=np.array([0, 0, 1])\n            )\n            \n            if corrected_intersection is None:\n                break\n            \n            current_point = corrected_intersection\n        \n        return current_point\n    \n    def get_terrain_slope(self, lon: float, lat: float, \n                         sample_distance: float = 10.0) -> Tuple[float, float]:\n        \"\"\"\n        Calculate terrain slope at given location\n        \n        Args:\n            lon: Longitude in degrees\n            lat: Latitude in degrees\n            sample_distance: Distance for slope calculation in meters\n            \n        Returns:\n            Slope in degrees (slope_x, slope_y)\n        \"\"\"\n        # Approximate degree offsets for sample distance\n        deg_per_meter_lat = 1.0 / 111320.0\n        deg_per_meter_lon = 1.0 / (111320.0 * np.cos(np.radians(lat)))\n        \n        offset_lon = sample_distance * deg_per_meter_lon\n        offset_lat = sample_distance * deg_per_meter_lat\n        \n        # Sample elevations\n        elev_center = self.get_elevation(lon, lat)\n        elev_east = self.get_elevation(lon + offset_lon, lat)\n        elev_west = self.get_elevation(lon - offset_lon, lat)\n        elev_north = self.get_elevation(lon, lat + offset_lat)\n        elev_south = self.get_elevation(lon, lat - offset_lat)\n        \n        # Calculate slopes\n        slope_x = np.arctan((elev_east - elev_west) / (2 * sample_distance))\n        slope_y = np.arctan((elev_north - elev_south) / (2 * sample_distance))\n        \n        return np.degrees(slope_x), np.degrees(slope_y)\n    \n    def get_terrain_normal(self, lon: float, lat: float, \n                          sample_distance: float = 10.0) -> np.ndarray:\n        \"\"\"\n        Calculate terrain normal vector at given location\n        \n        Args:\n            lon: Longitude in degrees\n            lat: Latitude in degrees\n            sample_distance: Distance for normal calculation in meters\n            \n        Returns:\n            Unit normal vector [nx, ny, nz]\n        \"\"\"\n        slope_x, slope_y = self.get_terrain_slope(lon, lat, sample_distance)\n        \n        # Convert slopes to radians\n        slope_x_rad = np.radians(slope_x)\n        slope_y_rad = np.radians(slope_y)\n        \n        # Calculate normal vector\n        nx = -np.sin(slope_x_rad)\n        ny = -np.sin(slope_y_rad)\n        nz = np.cos(slope_x_rad) * np.cos(slope_y_rad)\n        \n        # Normalize\n        normal = np.array([nx, ny, nz])\n        return normal / np.linalg.norm(normal)\n    \n    def get_coverage_area(self) -> Optional[Tuple[float, float, float, float]]:\n        \"\"\"\n        Get combined coverage area of all loaded DEMs\n        \n        Returns:\n            Combined bounds (min_lon, min_lat, max_lon, max_lat) or None\n        \"\"\"\n        if not self.dem_tiles:\n            return None\n        \n        min_lons, min_lats, max_lons, max_lats = zip(*[\n            tile.metadata.bounds for tile in self.dem_tiles\n        ])\n        \n        return (min(min_lons), min(min_lats), max(max_lons), max(max_lats))\n    \n    def get_resolution_at_point(self, lon: float, lat: float) -> Optional[float]:\n        \"\"\"Get DEM resolution at specific point\"\"\"\n        for dem_tile in self.dem_tiles:\n            if dem_tile.is_point_in_bounds(lon, lat):\n                return dem_tile.metadata.resolution\n        return None\n    \n    def clear_cache(self):\n        \"\"\"Clear elevation cache\"\"\"\n        self.cache.clear()\n    \n    def set_default_elevation(self, elevation: float):\n        \"\"\"Set default elevation for areas without DEM coverage\"\"\"\n        self.default_elevation = elevation\n    \n    def get_dem_info(self) -> Dict[str, Any]:\n        \"\"\"Get DEM information summary\"\"\"\n        if not self.dem_tiles:\n            return {'status': 'No DEM tiles loaded', 'default_elevation': self.default_elevation}\n        \n        coverage = self.get_coverage_area()\n        total_pixels = sum(tile.data.size for tile in self.dem_tiles)\n        \n        return {\n            'status': f'{len(self.dem_tiles)} DEM tiles loaded',\n            'coverage_area': coverage,\n            'total_pixels': total_pixels,\n            'cache_size': len(self.cache),\n            'default_elevation': self.default_elevation,\n            'tiles': [\n                {\n                    'format': tile.metadata.format.value,\n                    'resolution': tile.metadata.resolution,\n                    'bounds': tile.metadata.bounds,\n                    'size': f\"{tile.data.shape[1]}x{tile.data.shape[0]}\",\n                    'crs': tile.metadata.crs\n                }\n                for tile in self.dem_tiles\n            ]\n        }\n"},"query_language":"English"}}