"""\nCoordinate Transformation Module for Foresight SAR System\n\nThis module handles transformations between different coordinate systems\nincluding ENU (East-North-Up), NED (North-East-Down), ECEF (Earth-Centered\nEarth-Fixed), and geodetic coordinates (latitude, longitude, altitude).\n"""\n\nimport numpy as np\nfrom typing import Tuple, Union, Optional\nfrom dataclasses import dataclass\nfrom enum import Enum\nimport math\nimport logging\n\n\nclass CoordinateSystem(Enum):\n    \"\"\"Coordinate system types\"\"\"\n    GEODETIC = \"geodetic\"  # Latitude, Longitude, Altitude\n    ECEF = \"ecef\"          # Earth-Centered Earth-Fixed\n    ENU = \"enu\"            # East-North-Up (local tangent plane)\n    NED = \"ned\"            # North-East-Down (local tangent plane)\n    UTM = \"utm\"            # Universal Transverse Mercator\n\n\n@dataclass\nclass GeodeticCoordinate:\n    \"\"\"Geodetic coordinate (latitude, longitude, altitude)\"\"\"\n    latitude: float   # Degrees\n    longitude: float  # Degrees\n    altitude: float   # Meters above ellipsoid\n    \n    def __post_init__(self):\n        \"\"\"Validate coordinate ranges\"\"\"\n        if not (-90 <= self.latitude <= 90):\n            raise ValueError(f\"Latitude must be in [-90, 90], got {self.latitude}\")\n        if not (-180 <= self.longitude <= 180):\n            raise ValueError(f\"Longitude must be in [-180, 180], got {self.longitude}\")\n    \n    def to_radians(self) -> Tuple[float, float, float]:\n        \"\"\"Convert to radians\"\"\"\n        return (math.radians(self.latitude), \n                math.radians(self.longitude), \n                self.altitude)\n    \n    @classmethod\n    def from_radians(cls, lat_rad: float, lon_rad: float, alt: float) -> 'GeodeticCoordinate':\n        \"\"\"Create from radians\"\"\"\n        return cls(\n            latitude=math.degrees(lat_rad),\n            longitude=math.degrees(lon_rad),\n            altitude=alt\n        )\n\n\n@dataclass\nclass UTMCoordinate:\n    \"\"\"UTM coordinate\"\"\"\n    easting: float    # Meters\n    northing: float   # Meters\n    zone: int         # UTM zone (1-60)\n    hemisphere: str   # 'N' or 'S'\n    altitude: float = 0.0  # Meters\n\n\nclass WGS84Constants:\n    \"\"\"WGS84 ellipsoid constants\"\"\"\n    # Semi-major axis (meters)\n    A = 6378137.0\n    \n    # Flattening\n    F = 1.0 / 298.257223563\n    \n    # Semi-minor axis (meters)\n    B = A * (1.0 - F)\n    \n    # First eccentricity squared\n    E2 = F * (2.0 - F)\n    \n    # Second eccentricity squared\n    E2_PRIME = E2 / (1.0 - E2)\n\n\nclass CoordinateTransformer:\n    \"\"\"Coordinate system transformer\"\"\"\n    \n    def __init__(self, reference_point: Optional[GeodeticCoordinate] = None):\n        \"\"\"\n        Initialize coordinate transformer\n        \n        Args:\n            reference_point: Reference point for local coordinate systems (ENU/NED)\n        \"\"\"\n        self.reference_point = reference_point\n        self.reference_ecef = None\n        \n        if reference_point:\n            self.reference_ecef = self.geodetic_to_ecef(reference_point)\n    \n    def set_reference_point(self, reference_point: GeodeticCoordinate):\n        \"\"\"Set reference point for local coordinate systems\"\"\"\n        self.reference_point = reference_point\n        self.reference_ecef = self.geodetic_to_ecef(reference_point)\n    \n    def geodetic_to_ecef(self, coord: GeodeticCoordinate) -> np.ndarray:\n        \"\"\"\n        Convert geodetic coordinates to ECEF\n        \n        Args:\n            coord: Geodetic coordinate\n            \n        Returns:\n            ECEF coordinates [X, Y, Z] in meters\n        \"\"\"\n        lat_rad, lon_rad, alt = coord.to_radians()\n        \n        # Radius of curvature in the prime vertical\n        N = WGS84Constants.A / math.sqrt(1 - WGS84Constants.E2 * math.sin(lat_rad)**2)\n        \n        # ECEF coordinates\n        X = (N + alt) * math.cos(lat_rad) * math.cos(lon_rad)\n        Y = (N + alt) * math.cos(lat_rad) * math.sin(lon_rad)\n        Z = (N * (1 - WGS84Constants.E2) + alt) * math.sin(lat_rad)\n        \n        return np.array([X, Y, Z])\n    \n    def ecef_to_geodetic(self, ecef: np.ndarray) -> GeodeticCoordinate:\n        \"\"\"\n        Convert ECEF coordinates to geodetic\n        \n        Args:\n            ecef: ECEF coordinates [X, Y, Z] in meters\n            \n        Returns:\n            Geodetic coordinate\n        \"\"\"\n        X, Y, Z = ecef\n        \n        # Longitude\n        lon_rad = math.atan2(Y, X)\n        \n        # Distance from Z-axis\n        p = math.sqrt(X**2 + Y**2)\n        \n        # Initial latitude estimate\n        lat_rad = math.atan2(Z, p * (1 - WGS84Constants.E2))\n        \n        # Iterative solution for latitude and altitude\n        for _ in range(10):  # Usually converges in 2-3 iterations\n            N = WGS84Constants.A / math.sqrt(1 - WGS84Constants.E2 * math.sin(lat_rad)**2)\n            alt = p / math.cos(lat_rad) - N\n            lat_rad_new = math.atan2(Z, p * (1 - WGS84Constants.E2 * N / (N + alt)))\n            \n            if abs(lat_rad_new - lat_rad) < 1e-12:\n                break\n            lat_rad = lat_rad_new\n        \n        return GeodeticCoordinate.from_radians(lat_rad, lon_rad, alt)\n    \n    def geodetic_to_enu(self, coord: GeodeticCoordinate) -> np.ndarray:\n        \"\"\"\n        Convert geodetic coordinates to ENU (East-North-Up)\n        \n        Args:\n            coord: Geodetic coordinate\n            \n        Returns:\n            ENU coordinates [E, N, U] in meters\n        \"\"\"\n        if self.reference_point is None:\n            raise ValueError(\"Reference point not set for ENU conversion\")\n        \n        # Convert to ECEF\n        ecef = self.geodetic_to_ecef(coord)\n        \n        # Convert ECEF to ENU\n        return self.ecef_to_enu(ecef)\n    \n    def enu_to_geodetic(self, enu: np.ndarray) -> GeodeticCoordinate:\n        \"\"\"\n        Convert ENU coordinates to geodetic\n        \n        Args:\n            enu: ENU coordinates [E, N, U] in meters\n            \n        Returns:\n            Geodetic coordinate\n        \"\"\"\n        if self.reference_point is None:\n            raise ValueError(\"Reference point not set for ENU conversion\")\n        \n        # Convert ENU to ECEF\n        ecef = self.enu_to_ecef(enu)\n        \n        # Convert ECEF to geodetic\n        return self.ecef_to_geodetic(ecef)\n    \n    def ecef_to_enu(self, ecef: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Convert ECEF coordinates to ENU relative to reference point\n        \n        Args:\n            ecef: ECEF coordinates [X, Y, Z] in meters\n            \n        Returns:\n            ENU coordinates [E, N, U] in meters\n        \"\"\"\n        if self.reference_ecef is None:\n            raise ValueError(\"Reference point not set for ENU conversion\")\n        \n        # Vector from reference to point in ECEF\n        delta_ecef = ecef - self.reference_ecef\n        \n        # Reference point geodetic coordinates\n        lat_rad, lon_rad, _ = self.reference_point.to_radians()\n        \n        # Rotation matrix from ECEF to ENU\n        sin_lat, cos_lat = math.sin(lat_rad), math.cos(lat_rad)\n        sin_lon, cos_lon = math.sin(lon_rad), math.cos(lon_rad)\n        \n        R = np.array([\n            [-sin_lon, cos_lon, 0],\n            [-sin_lat * cos_lon, -sin_lat * sin_lon, cos_lat],\n            [cos_lat * cos_lon, cos_lat * sin_lon, sin_lat]\n        ])\n        \n        return R @ delta_ecef\n    \n    def enu_to_ecef(self, enu: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Convert ENU coordinates to ECEF\n        \n        Args:\n            enu: ENU coordinates [E, N, U] in meters\n            \n        Returns:\n            ECEF coordinates [X, Y, Z] in meters\n        \"\"\"\n        if self.reference_ecef is None:\n            raise ValueError(\"Reference point not set for ENU conversion\")\n        \n        # Reference point geodetic coordinates\n        lat_rad, lon_rad, _ = self.reference_point.to_radians()\n        \n        # Rotation matrix from ENU to ECEF (transpose of ECEF to ENU)\n        sin_lat, cos_lat = math.sin(lat_rad), math.cos(lat_rad)\n        sin_lon, cos_lon = math.sin(lon_rad), math.cos(lon_rad)\n        \n        R = np.array([\n            [-sin_lon, -sin_lat * cos_lon, cos_lat * cos_lon],\n            [cos_lon, -sin_lat * sin_lon, cos_lat * sin_lon],\n            [0, cos_lat, sin_lat]\n        ])\n        \n        # Transform to ECEF and add reference\n        delta_ecef = R @ enu\n        return self.reference_ecef + delta_ecef\n    \n    def enu_to_ned(self, enu: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Convert ENU to NED coordinates\n        \n        Args:\n            enu: ENU coordinates [E, N, U]\n            \n        Returns:\n            NED coordinates [N, E, D]\n        \"\"\"\n        E, N, U = enu\n        return np.array([N, E, -U])\n    \n    def ned_to_enu(self, ned: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Convert NED to ENU coordinates\n        \n        Args:\n            ned: NED coordinates [N, E, D]\n            \n        Returns:\n            ENU coordinates [E, N, U]\n        \"\"\"\n        N, E, D = ned\n        return np.array([E, N, -D])\n    \n    def geodetic_to_utm(self, coord: GeodeticCoordinate) -> UTMCoordinate:\n        \"\"\"\n        Convert geodetic coordinates to UTM\n        \n        Args:\n            coord: Geodetic coordinate\n            \n        Returns:\n            UTM coordinate\n        \"\"\"\n        lat_rad, lon_rad, alt = coord.to_radians()\n        \n        # UTM zone calculation\n        zone = int((coord.longitude + 180) / 6) + 1\n        \n        # Central meridian of the zone\n        lon0_rad = math.radians((zone - 1) * 6 - 180 + 3)\n        \n        # UTM projection parameters\n        k0 = 0.9996  # Scale factor\n        \n        # Ellipsoid parameters\n        a = WGS84Constants.A\n        e2 = WGS84Constants.E2\n        e2_prime = WGS84Constants.E2_PRIME\n        \n        # Intermediate calculations\n        N = a / math.sqrt(1 - e2 * math.sin(lat_rad)**2)\n        T = math.tan(lat_rad)**2\n        C = e2_prime * math.cos(lat_rad)**2\n        A_coeff = math.cos(lat_rad) * (lon_rad - lon0_rad)\n        \n        # Meridional arc\n        M = a * ((1 - e2/4 - 3*e2**2/64 - 5*e2**3/256) * lat_rad -\n                 (3*e2/8 + 3*e2**2/32 + 45*e2**3/1024) * math.sin(2*lat_rad) +\n                 (15*e2**2/256 + 45*e2**3/1024) * math.sin(4*lat_rad) -\n                 (35*e2**3/3072) * math.sin(6*lat_rad))\n        \n        # UTM coordinates\n        easting = (k0 * N * (A_coeff + (1-T+C) * A_coeff**3/6 +\n                             (5-18*T+T**2+72*C-58*e2_prime) * A_coeff**5/120) + 500000)\n        \n        northing = (k0 * (M + N * math.tan(lat_rad) *\n                         (A_coeff**2/2 + (5-T+9*C+4*C**2) * A_coeff**4/24 +\n                          (61-58*T+T**2+600*C-330*e2_prime) * A_coeff**6/720)))\n        \n        # Adjust for southern hemisphere\n        hemisphere = 'N' if coord.latitude >= 0 else 'S'\n        if hemisphere == 'S':\n            northing += 10000000\n        \n        return UTMCoordinate(\n            easting=easting,\n            northing=northing,\n            zone=zone,\n            hemisphere=hemisphere,\n            altitude=alt\n        )\n    \n    def utm_to_geodetic(self, utm: UTMCoordinate) -> GeodeticCoordinate:\n        \"\"\"\n        Convert UTM coordinates to geodetic\n        \n        Args:\n            utm: UTM coordinate\n            \n        Returns:\n            Geodetic coordinate\n        \"\"\"\n        # Central meridian of the zone\n        lon0_rad = math.radians((utm.zone - 1) * 6 - 180 + 3)\n        \n        # UTM projection parameters\n        k0 = 0.9996\n        \n        # Ellipsoid parameters\n        a = WGS84Constants.A\n        e2 = WGS84Constants.E2\n        e2_prime = WGS84Constants.E2_PRIME\n        e1 = (1 - math.sqrt(1 - e2)) / (1 + math.sqrt(1 - e2))\n        \n        # Adjust northing for southern hemisphere\n        northing = utm.northing\n        if utm.hemisphere == 'S':\n            northing -= 10000000\n        \n        # Remove false easting\n        easting = utm.easting - 500000\n        \n        # Footprint latitude\n        M = northing / k0\n        mu = M / (a * (1 - e2/4 - 3*e2**2/64 - 5*e2**3/256))\n        \n        lat1_rad = (mu + (3*e1/2 - 27*e1**3/32) * math.sin(2*mu) +\n                   (21*e1**2/16 - 55*e1**4/32) * math.sin(4*mu) +\n                   (151*e1**3/96) * math.sin(6*mu))\n        \n        # Intermediate calculations\n        N1 = a / math.sqrt(1 - e2 * math.sin(lat1_rad)**2)\n        T1 = math.tan(lat1_rad)**2\n        C1 = e2_prime * math.cos(lat1_rad)**2\n        R1 = a * (1 - e2) / (1 - e2 * math.sin(lat1_rad)**2)**(3/2)\n        D = easting / (N1 * k0)\n        \n        # Latitude\n        lat_rad = (lat1_rad - (N1 * math.tan(lat1_rad) / R1) *\n                  (D**2/2 - (5+3*T1+10*C1-4*C1**2-9*e2_prime) * D**4/24 +\n                   (61+90*T1+298*C1+45*T1**2-252*e2_prime-3*C1**2) * D**6/720))\n        \n        # Longitude\n        lon_rad = (lon0_rad + (D - (1+2*T1+C1) * D**3/6 +\n                              (5-2*C1+28*T1-3*C1**2+8*e2_prime+24*T1**2) * D**5/120) /\n                  math.cos(lat1_rad))\n        \n        return GeodeticCoordinate.from_radians(lat_rad, lon_rad, utm.altitude)\n    \n    def calculate_distance(self, coord1: GeodeticCoordinate, \n                          coord2: GeodeticCoordinate) -> float:\n        \"\"\"\n        Calculate great circle distance between two geodetic points\n        \n        Args:\n            coord1: First geodetic coordinate\n            coord2: Second geodetic coordinate\n            \n        Returns:\n            Distance in meters\n        \"\"\"\n        lat1_rad, lon1_rad, _ = coord1.to_radians()\n        lat2_rad, lon2_rad, _ = coord2.to_radians()\n        \n        # Haversine formula\n        dlat = lat2_rad - lat1_rad\n        dlon = lon2_rad - lon1_rad\n        \n        a = (math.sin(dlat/2)**2 + \n             math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2)\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))\n        \n        return WGS84Constants.A * c\n    \n    def calculate_bearing(self, coord1: GeodeticCoordinate, \n                        coord2: GeodeticCoordinate) -> float:\n        \"\"\"\n        Calculate initial bearing from coord1 to coord2\n        \n        Args:\n            coord1: Starting geodetic coordinate\n            coord2: Ending geodetic coordinate\n            \n        Returns:\n            Bearing in degrees (0-360)\n        \"\"\"\n        lat1_rad, lon1_rad, _ = coord1.to_radians()\n        lat2_rad, lon2_rad, _ = coord2.to_radians()\n        \n        dlon = lon2_rad - lon1_rad\n        \n        y = math.sin(dlon) * math.cos(lat2_rad)\n        x = (math.cos(lat1_rad) * math.sin(lat2_rad) - \n             math.sin(lat1_rad) * math.cos(lat2_rad) * math.cos(dlon))\n        \n        bearing_rad = math.atan2(y, x)\n        bearing_deg = math.degrees(bearing_rad)\n        \n        # Normalize to 0-360\n        return (bearing_deg + 360) % 360\n    \n    def transform_coordinates(self, coordinates: np.ndarray, \n                            from_system: CoordinateSystem,\n                            to_system: CoordinateSystem) -> np.ndarray:\n        \"\"\"\n        Transform coordinates between different systems\n        \n        Args:\n            coordinates: Input coordinates\n            from_system: Source coordinate system\n            to_system: Target coordinate system\n            \n        Returns:\n            Transformed coordinates\n        \"\"\"\n        if from_system == to_system:\n            return coordinates.copy()\n        \n        # Convert to intermediate format (ECEF) if needed\n        if from_system == CoordinateSystem.GEODETIC:\n            coord = GeodeticCoordinate(*coordinates)\n            ecef = self.geodetic_to_ecef(coord)\n        elif from_system == CoordinateSystem.ENU:\n            ecef = self.enu_to_ecef(coordinates)\n        elif from_system == CoordinateSystem.NED:\n            enu = self.ned_to_enu(coordinates)\n            ecef = self.enu_to_ecef(enu)\n        elif from_system == CoordinateSystem.ECEF:\n            ecef = coordinates\n        else:\n            raise ValueError(f\"Unsupported source coordinate system: {from_system}\")\n        \n        # Convert from ECEF to target system\n        if to_system == CoordinateSystem.GEODETIC:\n            coord = self.ecef_to_geodetic(ecef)\n            return np.array([coord.latitude, coord.longitude, coord.altitude])\n        elif to_system == CoordinateSystem.ENU:\n            return self.ecef_to_enu(ecef)\n        elif to_system == CoordinateSystem.NED:\n            enu = self.ecef_to_enu(ecef)\n            return self.enu_to_ned(enu)\n        elif to_system == CoordinateSystem.ECEF:\n            return ecef\n        else:\n            raise ValueError(f\"Unsupported target coordinate system: {to_system}\")\n    \n    def get_transformation_info(self) -> dict:\n        \"\"\"Get transformation information summary\"\"\"\n        info = {\n            'supported_systems': [system.value for system in CoordinateSystem],\n            'reference_point': None\n        }\n        \n        if self.reference_point:\n            info['reference_point'] = {\n                'latitude': self.reference_point.latitude,\n                'longitude': self.reference_point.longitude,\n                'altitude': self.reference_point.altitude\n            }\n        \n        return info\n"},"query_language":"English"}}