"""\nGeolocation Service for Foresight SAR System\n\nThis module provides the main geolocation service that integrates camera\ncalibration, pinhole projection, coordinate transformation, and DEM correction\nto provide accurate geographic positioning of detected objects.\n"""\n\nimport numpy as np\nfrom typing import Dict, List, Optional, Tuple, Union, Any\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nimport logging\nfrom enum import Enum\nimport json\nfrom datetime import datetime\n\nfrom .camera_calibration import CameraCalibrator, CalibrationData\nfrom .projection import PinholeProjector, CameraPose, Ray3D, CoordinateSystem\nfrom .coordinate_transform import CoordinateTransformer, GeodeticCoordinate\nfrom .dem_correction import DEMCorrector, InterpolationMethod\n\n\nclass GeolocationMethod(Enum):\n    \"\"\"Geolocation calculation methods\"\"\"\n    FLAT_EARTH = \"flat_earth\"  # Assume flat ground plane\n    DEM_CORRECTED = \"dem_corrected\"  # Use DEM for terrain correction\n    STEREO_TRIANGULATION = \"stereo_triangulation\"  # Multiple view triangulation\n    RANGE_CONSTRAINED = \"range_constrained\"  # Known range constraint\n\n\nclass ConfidenceLevel(Enum):\n    \"\"\"Geolocation confidence levels\"\"\"\n    HIGH = \"high\"      # < 5m error\n    MEDIUM = \"medium\"  # 5-20m error\n    LOW = \"low\"        # > 20m error\n    UNKNOWN = \"unknown\"\n\n\n@dataclass\nclass GeolocationResult:\n    \"\"\"Geolocation calculation result\"\"\"\n    # Geographic position\n    latitude: float\n    longitude: float\n    altitude: float\n    \n    # Local coordinates (if reference point set)\n    local_coordinates: Optional[np.ndarray] = None\n    \n    # Uncertainty estimates\n    horizontal_error: Optional[float] = None  # meters\n    vertical_error: Optional[float] = None    # meters\n    confidence: ConfidenceLevel = ConfidenceLevel.UNKNOWN\n    \n    # Method and metadata\n    method: GeolocationMethod = GeolocationMethod.FLAT_EARTH\n    pixel_coordinates: Optional[Tuple[float, float]] = None\n    camera_pose: Optional[CameraPose] = None\n    \n    # Additional information\n    dem_elevation: Optional[float] = None\n    ground_distance: Optional[float] = None\n    bearing: Optional[float] = None\n    elevation_angle: Optional[float] = None\n    \n    # Quality metrics\n    ray_ground_angle: Optional[float] = None\n    terrain_slope: Optional[Tuple[float, float]] = None\n    \n    # Timestamp\n    timestamp: str = field(default_factory=lambda: datetime.utcnow().isoformat())\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary for serialization\"\"\"\n        result = {\n            'latitude': self.latitude,\n            'longitude': self.longitude,\n            'altitude': self.altitude,\n            'confidence': self.confidence.value,\n            'method': self.method.value,\n            'timestamp': self.timestamp\n        }\n        \n        # Add optional fields if present\n        if self.local_coordinates is not None:\n            result['local_coordinates'] = self.local_coordinates.tolist()\n        if self.horizontal_error is not None:\n            result['horizontal_error'] = self.horizontal_error\n        if self.vertical_error is not None:\n            result['vertical_error'] = self.vertical_error\n        if self.pixel_coordinates is not None:\n            result['pixel_coordinates'] = self.pixel_coordinates\n        if self.dem_elevation is not None:\n            result['dem_elevation'] = self.dem_elevation\n        if self.ground_distance is not None:\n            result['ground_distance'] = self.ground_distance\n        if self.bearing is not None:\n            result['bearing'] = self.bearing\n        if self.elevation_angle is not None:\n            result['elevation_angle'] = self.elevation_angle\n        if self.ray_ground_angle is not None:\n            result['ray_ground_angle'] = self.ray_ground_angle\n        if self.terrain_slope is not None:\n            result['terrain_slope'] = self.terrain_slope\n        \n        return result\n\n\n@dataclass\nclass GeolocationConfig:\n    \"\"\"Geolocation service configuration\"\"\"\n    # Default method\n    default_method: GeolocationMethod = GeolocationMethod.FLAT_EARTH\n    \n    # Ground plane settings\n    default_ground_height: float = 0.0\n    \n    # DEM settings\n    dem_interpolation: InterpolationMethod = InterpolationMethod.BILINEAR\n    dem_correction_tolerance: float = 1.0\n    dem_max_iterations: int = 10\n    \n    # Error estimation\n    estimate_errors: bool = True\n    pixel_error_std: float = 1.0  # pixels\n    pose_position_error_std: float = 5.0  # meters\n    pose_orientation_error_std: float = 1.0  # degrees\n    \n    # Quality thresholds\n    min_ray_ground_angle: float = 10.0  # degrees\n    max_horizontal_error: float = 100.0  # meters\n    \n    # Coordinate system\n    output_coordinate_system: CoordinateSystem = CoordinateSystem.GEODETIC\n\n\nclass GeolocationService:\n    \"\"\"Main geolocation service\"\"\"\n    \n    def __init__(self, \n                 calibration_file: Optional[str] = None,\n                 config: Optional[GeolocationConfig] = None):\n        \"\"\"\n        Initialize geolocation service\n        \n        Args:\n            calibration_file: Path to camera calibration file\n            config: Service configuration\n        \"\"\"\n        self.config = config or GeolocationConfig()\n        \n        # Initialize components\n        self.calibrator = CameraCalibrator(calibration_file)\n        self.projector = None\n        self.coordinate_transformer = CoordinateTransformer()\n        self.dem_corrector = DEMCorrector(self.coordinate_transformer)\n        \n        # Initialize projector if calibration is available\n        if self.calibrator.calibration_data:\n            self.projector = PinholeProjector(self.calibrator.calibration_data)\n        \n        # Current camera pose\n        self.current_pose: Optional[CameraPose] = None\n        \n        # Statistics\n        self.stats = {\n            'total_geolocations': 0,\n            'successful_geolocations': 0,\n            'method_counts': {method.value: 0 for method in GeolocationMethod},\n            'confidence_counts': {conf.value: 0 for conf in ConfidenceLevel}\n        }\n    \n    def load_calibration(self, calibration_file: str):\n        \"\"\"Load camera calibration\"\"\"\n        self.calibrator.load_calibration(calibration_file)\n        if self.calibrator.calibration_data:\n            self.projector = PinholeProjector(self.calibrator.calibration_data)\n            logging.info(\"Camera calibration loaded and projector initialized\")\n    \n    def set_camera_pose(self, pose: CameraPose):\n        \"\"\"Set current camera pose\"\"\"\n        self.current_pose = pose\n        logging.debug(f\"Camera pose updated: position={pose.position}, coordinate_system={pose.coordinate_system.value}\")\n    \n    def set_reference_point(self, reference: GeodeticCoordinate):\n        \"\"\"Set reference point for local coordinate systems\"\"\"\n        self.coordinate_transformer.set_reference_point(reference)\n        logging.info(f\"Reference point set: {reference.latitude:.6f}, {reference.longitude:.6f}\")\n    \n    def load_dem(self, dem_file: str):\n        \"\"\"Load DEM file\"\"\"\n        self.dem_corrector.load_dem_file(dem_file)\n        logging.info(f\"DEM loaded from {dem_file}\")\n    \n    def geolocate_pixel(self, \n                       pixel_coords: Union[Tuple[float, float], np.ndarray],\n                       camera_pose: Optional[CameraPose] = None,\n                       method: Optional[GeolocationMethod] = None,\n                       ground_height: Optional[float] = None) -> Optional[GeolocationResult]:\n        \"\"\"\n        Geolocate a pixel coordinate\n        \n        Args:\n            pixel_coords: Pixel coordinates [u, v]\n            camera_pose: Camera pose (uses current if None)\n            method: Geolocation method (uses default if None)\n            ground_height: Ground height for flat earth method\n            \n        Returns:\n            Geolocation result or None if failed\n        \"\"\"\n        self.stats['total_geolocations'] += 1\n        \n        # Validate inputs\n        if self.projector is None:\n            logging.error(\"No camera calibration available\")\n            return None\n        \n        pose = camera_pose or self.current_pose\n        if pose is None:\n            logging.error(\"No camera pose available\")\n            return None\n        \n        method = method or self.config.default_method\n        ground_height = ground_height if ground_height is not None else self.config.default_ground_height\n        \n        try:\n            # Convert pixel to ray\n            ray = self.projector.pixel_to_ray(pixel_coords, pose)\n            \n            # Calculate intersection based on method\n            if method == GeolocationMethod.FLAT_EARTH:\n                intersection = self._flat_earth_intersection(ray, ground_height)\n            elif method == GeolocationMethod.DEM_CORRECTED:\n                intersection = self._dem_corrected_intersection(ray, ground_height)\n            else:\n                logging.warning(f\"Method {method.value} not implemented, using flat earth\")\n                intersection = self._flat_earth_intersection(ray, ground_height)\n                method = GeolocationMethod.FLAT_EARTH\n            \n            if intersection is None:\n                logging.warning(\"Failed to calculate ground intersection\")\n                return None\n            \n            # Convert to geodetic coordinates\n            result = self._create_geolocation_result(\n                intersection, ray, pose, method, pixel_coords\n            )\n            \n            # Update statistics\n            self.stats['successful_geolocations'] += 1\n            self.stats['method_counts'][method.value] += 1\n            self.stats['confidence_counts'][result.confidence.value] += 1\n            \n            return result\n            \n        except Exception as e:\n            logging.error(f\"Geolocation failed: {e}\")\n            return None\n    \n    def _flat_earth_intersection(self, ray: Ray3D, ground_height: float) -> Optional[np.ndarray]:\n        \"\"\"Calculate intersection with flat ground plane\"\"\"\n        return ray.intersect_ground_plane(ground_height)\n    \n    def _dem_corrected_intersection(self, ray: Ray3D, initial_height: float) -> Optional[np.ndarray]:\n        \"\"\"Calculate DEM-corrected intersection\"\"\"\n        # Start with flat earth intersection\n        initial_intersection = ray.intersect_ground_plane(initial_height)\n        if initial_intersection is None:\n            return None\n        \n        # Apply DEM correction\n        return self.dem_corrector.correct_ray_ground_intersection(\n            ray, initial_intersection,\n            max_iterations=self.config.dem_max_iterations,\n            tolerance=self.config.dem_correction_tolerance\n        )\n    \n    def _create_geolocation_result(self, \n                                  intersection: np.ndarray,\n                                  ray: Ray3D,\n                                  pose: CameraPose,\n                                  method: GeolocationMethod,\n                                  pixel_coords: Union[Tuple[float, float], np.ndarray]) -> GeolocationResult:\n        \"\"\"Create geolocation result from intersection point\"\"\"\n        # Convert intersection to geodetic coordinates\n        if pose.coordinate_system == CoordinateSystem.ENU and self.coordinate_transformer.reference_point:\n            geodetic = self.coordinate_transformer.enu_to_geodetic(intersection)\n            local_coords = intersection\n        else:\n            # Assume intersection is already in world coordinates\n            # For now, treat as geodetic [lon, lat, alt]\n            geodetic = GeodeticCoordinate(\n                latitude=intersection[1],\n                longitude=intersection[0],\n                altitude=intersection[2]\n            )\n            local_coords = None\n        \n        # Calculate additional metrics\n        ground_distance = np.linalg.norm(intersection - ray.origin)\n        bearing = self._calculate_bearing(ray.origin, intersection)\n        elevation_angle = self._calculate_elevation_angle(ray)\n        ray_ground_angle = self._calculate_ray_ground_angle(ray)\n        \n        # Get DEM elevation if available\n        dem_elevation = None\n        terrain_slope = None\n        if self.dem_corrector.dem_tiles:\n            dem_elevation = self.dem_corrector.get_elevation(geodetic.longitude, geodetic.latitude)\n            terrain_slope = self.dem_corrector.get_terrain_slope(geodetic.longitude, geodetic.latitude)\n        \n        # Estimate errors\n        horizontal_error, vertical_error = None, None\n        if self.config.estimate_errors:\n            horizontal_error, vertical_error = self._estimate_errors(\n                ray, intersection, pose, method\n            )\n        \n        # Determine confidence\n        confidence = self._determine_confidence(\n            horizontal_error, vertical_error, ray_ground_angle, method\n        )\n        \n        return GeolocationResult(\n            latitude=geodetic.latitude,\n            longitude=geodetic.longitude,\n            altitude=geodetic.altitude,\n            local_coordinates=local_coords,\n            horizontal_error=horizontal_error,\n            vertical_error=vertical_error,\n            confidence=confidence,\n            method=method,\n            pixel_coordinates=tuple(pixel_coords) if isinstance(pixel_coords, np.ndarray) else pixel_coords,\n            camera_pose=pose,\n            dem_elevation=dem_elevation,\n            ground_distance=ground_distance,\n            bearing=bearing,\n            elevation_angle=elevation_angle,\n            ray_ground_angle=ray_ground_angle,\n            terrain_slope=terrain_slope\n        )\n    \n    def _calculate_bearing(self, origin: np.ndarray, target: np.ndarray) -> float:\n        \"\"\"Calculate bearing from origin to target\"\"\"\n        delta = target - origin\n        bearing_rad = np.arctan2(delta[0], delta[1])  # East, North\n        bearing_deg = np.degrees(bearing_rad)\n        return (bearing_deg + 360) % 360\n    \n    def _calculate_elevation_angle(self, ray: Ray3D) -> float:\n        \"\"\"Calculate elevation angle of ray\"\"\"\n        # Angle below horizontal\n        horizontal_distance = np.linalg.norm(ray.direction[:2])\n        elevation_rad = np.arctan2(-ray.direction[2], horizontal_distance)\n        return np.degrees(elevation_rad)\n    \n    def _calculate_ray_ground_angle(self, ray: Ray3D) -> float:\n        \"\"\"Calculate angle between ray and ground plane\"\"\"\n        ground_normal = np.array([0, 0, 1])\n        cos_angle = abs(np.dot(ray.direction, ground_normal))\n        angle_rad = np.arccos(np.clip(cos_angle, 0, 1))\n        return np.degrees(angle_rad)\n    \n    def _estimate_errors(self, \n                        ray: Ray3D, \n                        intersection: np.ndarray,\n                        pose: CameraPose,\n                        method: GeolocationMethod) -> Tuple[float, float]:\n        \"\"\"Estimate horizontal and vertical errors\"\"\"\n        # Simple error propagation model\n        # This is a simplified approach - real error analysis would be more complex\n        \n        distance = np.linalg.norm(intersection - ray.origin)\n        ray_angle = self._calculate_ray_ground_angle(ray)\n        \n        # Base errors from pixel uncertainty\n        if self.projector:\n            fx, fy = self.projector.calibration.get_focal_lengths()\n            pixel_angular_error = self.config.pixel_error_std / min(fx, fy)\n            angular_error_at_distance = pixel_angular_error * distance\n        else:\n            angular_error_at_distance = 1.0\n        \n        # Position error contribution\n        position_error = self.config.pose_position_error_std\n        \n        # Orientation error contribution\n        orientation_error_rad = np.radians(self.config.pose_orientation_error_std)\n        orientation_error_at_distance = orientation_error_rad * distance\n        \n        # Combine errors\n        horizontal_error = np.sqrt(\n            angular_error_at_distance**2 + \n            position_error**2 + \n            orientation_error_at_distance**2\n        )\n        \n        # Vertical error depends on ray angle\n        if ray_angle > 0:\n            vertical_error = horizontal_error / np.sin(np.radians(ray_angle))\n        else:\n            vertical_error = float('inf')\n        \n        # Method-specific adjustments\n        if method == GeolocationMethod.DEM_CORRECTED:\n            # DEM adds some uncertainty\n            dem_resolution = self.dem_corrector.get_resolution_at_point(\n                intersection[0], intersection[1]\n            )\n            if dem_resolution:\n                horizontal_error = np.sqrt(horizontal_error**2 + (dem_resolution/2)**2)\n        \n        return horizontal_error, min(vertical_error, 1000.0)  # Cap vertical error\n    \n    def _determine_confidence(self, \n                            horizontal_error: Optional[float],\n                            vertical_error: Optional[float],\n                            ray_ground_angle: Optional[float],\n                            method: GeolocationMethod) -> ConfidenceLevel:\n        \"\"\"Determine confidence level\"\"\"\n        if horizontal_error is None or ray_ground_angle is None:\n            return ConfidenceLevel.UNKNOWN\n        \n        # Check ray angle\n        if ray_ground_angle < self.config.min_ray_ground_angle:\n            return ConfidenceLevel.LOW\n        \n        # Check horizontal error\n        if horizontal_error > self.config.max_horizontal_error:\n            return ConfidenceLevel.LOW\n        elif horizontal_error < 5.0:\n            return ConfidenceLevel.HIGH\n        elif horizontal_error < 20.0:\n            return ConfidenceLevel.MEDIUM\n        else:\n            return ConfidenceLevel.LOW\n    \n    def geolocate_multiple_pixels(self, \n                                 pixel_list: List[Union[Tuple[float, float], np.ndarray]],\n                                 camera_pose: Optional[CameraPose] = None,\n                                 method: Optional[GeolocationMethod] = None) -> List[Optional[GeolocationResult]]:\n        \"\"\"Geolocate multiple pixels\"\"\"\n        return [\n            self.geolocate_pixel(pixel, camera_pose, method)\n            for pixel in pixel_list\n        ]\n    \n    def export_results(self, results: List[GeolocationResult], \n                      output_file: str, format: str = 'json'):\n        \"\"\"Export geolocation results\"\"\"\n        if format.lower() == 'json':\n            data = {\n                'metadata': {\n                    'timestamp': datetime.utcnow().isoformat(),\n                    'total_results': len(results),\n                    'service_config': {\n                        'default_method': self.config.default_method.value,\n                        'coordinate_system': self.config.output_coordinate_system.value\n                    }\n                },\n                'results': [result.to_dict() for result in results]\n            }\n            \n            with open(output_file, 'w') as f:\n                json.dump(data, f, indent=2)\n        \n        logging.info(f\"Exported {len(results)} results to {output_file}\")\n    \n    def get_service_status(self) -> Dict[str, Any]:\n        \"\"\"Get service status and statistics\"\"\"\n        status = {\n            'calibration_loaded': self.calibrator.calibration_data is not None,\n            'projector_ready': self.projector is not None,\n            'current_pose_set': self.current_pose is not None,\n            'reference_point_set': self.coordinate_transformer.reference_point is not None,\n            'dem_loaded': len(self.dem_corrector.dem_tiles) > 0,\n            'statistics': self.stats.copy()\n        }\n        \n        if self.calibrator.calibration_data:\n            status['calibration_info'] = self.calibrator.get_calibration_info()\n        \n        if self.projector:\n            status['projection_info'] = self.projector.get_projection_info()\n        \n        if self.dem_corrector.dem_tiles:\n            status['dem_info'] = self.dem_corrector.get_dem_info()\n        \n        return status\n    \n    def reset_statistics(self):\n        \"\"\"Reset service statistics\"\"\"\n        self.stats = {\n            'total_geolocations': 0,\n            'successful_geolocations': 0,\n            'method_counts': {method.value: 0 for method in GeolocationMethod},\n            'confidence_counts': {conf.value: 0 for conf in ConfidenceLevel}\n        }\n"},"query_language":"English"}}